{"version":3,"sources":["/Users/marioncasters/Sites/GIT/marioncasters-site/src/constants/lightboxConstants.js","/Users/marioncasters/Sites/GIT/marioncasters-site/src/components/Lightbox/Lightbox.js","/Users/marioncasters/Sites/GIT/marioncasters-site/src/components/LightBoxProvider/LightBoxProvider.js","/Users/marioncasters/Sites/GIT/marioncasters-site/src/components/ItemDir/Image/Image.js","/Users/marioncasters/Sites/GIT/marioncasters-site/src/app-services/ItemService.js"],"names":["MIN_ZOOM_LEVEL","MAX_ZOOM_LEVEL","ZOOM_RATIO","ZOOM_BUTTON_INCREMENT_SIZE","WHEEL_MOVE_X_THRESHOLD","WHEEL_MOVE_Y_THRESHOLD","KEYS","ESC","LEFT_ARROW","RIGHT_ARROW","ACTION_NONE","ACTION_MOVE","ACTION_SWIPE","ACTION_PINCH","SOURCE_ANY","SOURCE_MOUSE","SOURCE_TOUCH","SOURCE_POINTER","MIN_SWIPE_DISTANCE","LIGHTBOX_PADDING","LIGHTBOX_MOBILE_PADDING","Lightbox","Component","target","test","className","mouseEvent","id","source","x","parseInt","clientX","y","clientY","touchPointer","identifier","pointerEvent","pointerId","constructor","props","super","this","state","isClosing","animationDisabled","shouldAnimate","zoomLevel","offsetX","offsetY","loadErrorStatus","closeIfClickInner","bind","handleImageDoubleClick","handleImageMouseWheel","handleKeyInput","handleMouseUp","handleMouseDown","handleMouseMove","handleOuterMousewheel","handleTouchStart","handleTouchMove","handleTouchEnd","handlePointerEvent","handleCaptionMousewheel","handleWindowResize","handleZoomInButtonClick","handleZoomOutButtonClick","requestClose","requestMoveNext","requestMovePrev","UNSAFE_componentWillMount","timeouts","currentAction","eventsSource","pointerList","preventInnerClose","preventInnerCloseTimeout","keyPressed","imageCache","lastKeyDownTime","resizeTimeout","wheelActionTimeout","resetScrollTimeout","scrollX","scrollY","moveStartX","moveStartY","moveStartOffsetX","moveStartOffsetY","swipeStartX","swipeStartY","swipeEndX","swipeEndY","pinchTouchList","pinchDistance","keyCounter","moveRequested","setState","componentDidMount","windowContext","getHighestSafeWindowContext","listeners","resize","mouseup","touchend","touchcancel","pointerdown","pointermove","pointerup","pointercancel","Object","keys","forEach","type","addEventListener","loadAllImages","UNSAFE_componentWillReceiveProps","nextProps","sourcesChanged","prevSrcDict","nextSrcDict","getSrcTypes","srcType","name","prevSrc","loaded","shouldComponentUpdate","componentWillUnmount","didUnmount","removeEventListener","tid","clearTimeout","setTimeout","func","time","filter","push","zoom","width","targetWidth","nextX","windowWidth","getWindowWidth","scaleFactor","transform","setPreventInnerClose","getBestImageForType","imageSrc","fitSizes","isImageLoaded","getFitSizes","height","src","targetHeight","stretch","boxSize","getLightboxRect","maxHeight","maxWidth","mobileSizeBreakpoint","imageMobilePadding","imagePadding","Math","min","getMaxOffsets","currentImageInfo","maxX","minX","maxY","minY","zoomMultiplier","getZoomMultiplier","keyEnding","outerEl","getBoundingClientRect","getWindowHeight","top","right","bottom","left","changeZoom","enableZoom","nextZoomLevel","max","imageBaseSize","currentZoomMultiplier","nextZoomMultiplier","boxRect","pointerX","pointerY","currentImageOffsetX","currentImageOffsetY","nextImageRealOffsetX","nextImageRealOffsetY","nextOffsetX","nextOffsetY","maxOffsets","event","search","stopPropagation","isAnimating","keyRepeatKeyupBonus","keyCode","which","currentTime","Date","getTime","keyRepeatLimit","preventDefault","nextSrc","xThreshold","actionDelay","abs","deltaY","deltaX","bigLeapX","yThreshold","shouldHandleEvent","filterPointersBySource","addPointer","pointer","removePointer","isTargetMatchImage","parseMouseEvent","multiPointerStart","multiPointerMove","multiPointerEnd","parsePointerEvent","call","changedTouches","eventTouch","parseTouchPointer","map","touch","decideMoveOrSwipe","handleSwipeStart","handleMoveStart","handleEnd","length","handlePinchStart","handleMove","handleSwipe","handlePinch","handleMoveEnd","handleSwipeEnd","handlePinchEnd","newOffsetX","newOffsetY","animationDuration","xDiff","xDiffAbs","yDiffAbs","calculatePinchDistance","a","b","sqrt","calculatePinchCenter","oldPointer","i","newDistance","forceUpdate","zoomOutBtn","focus","zoomInBtn","caption","scrollHeight","scrollTop","loadImage","done","inMemoryImage","global","Image","imageCrossOrigin","crossOrigin","onerror","errorEvent","onImageLoadError","prevState","onload","onImageLoad","generateLoadDoneCallback","err","closeLightbox","onCloseRequest","animationOnKeyInput","requestMove","direction","nextState","onMovePrevRequest","onMoveNextRequest","render","clickOutsideToClose","discourageDownloads","imageTitle","toolbarButtons","reactModalStyle","onAfterOpen","reactModalProps","transitionStyle","transition","keyEndings","images","addImage","imageClass","transforms","bestImageInfo","imageStyle","getTransform","cursor","object","some","key","hasTrueValue","s","ril__image","style","imageLoadErrorMessage","loadingIcon","ril__loadingCircle","ril__loadingContainer__icon","Array","_","index","ril__loadingCirclePoint","ril__loadingContainer","backgroundImage","ril__imageDiscourager","onDoubleClick","onWheel","ril__downloadBlocker","onDragStart","e","alt","translate","draggable","modalStyle","overlay","zIndex","backgroundColor","content","overflow","border","borderRadius","padding","isOpen","onRequestClose","undefined","contentLabel","appElement","window","document","body","ril__outer","ril__outerAnimating","wrapperClassName","ril__outerClosing","animationDirection","ref","el","onMouseMove","onMouseDown","onTouchStart","onTouchMove","tabIndex","onKeyDown","onKeyUp","ril__inner","onClick","ril__navButtons","ril__navButtonPrev","aria-label","prevLabel","ril__navButtonNext","nextLabel","ril__toolbar","ril__toolbarSide","ril__toolbarLeftSide","ril__toolbarItem","ril__toolbarItemChild","ril__toolbarRightSide","button","zoomInLabel","ril__builtinButton","ril__zoomInButton","ril__builtinButtonDisabled","join","disabled","zoomOutLabel","ril__zoomOutButton","closeLabel","ril__closeButton","imageCaption","ril__caption","ril__captionContent","propTypes","mainSrc","PropTypes","string","isRequired","mainSrcThumbnail","prevSrcThumbnail","nextSrcThumbnail","bool","number","node","shape","arrayOf","defaultProps","LightBoxProvider","title","srcList","toggle","photoIndex","setPhotoIndex","useState","close","ITEM","SCULPTURE","TYPE","LAYOUT_CONSTANTS","BREAKPOINT","MD","Modal","setAppElement","array","useViewport","setIsOpen","isLessThanSM","SM","itemService","ItemService","itemPath","getPath","getAltImage","isSculpture","getIsSculpture","currentImagePath","largeImagePath","getSrcList","isCurrent","list","path","openLightBox","SM_SIZE","MD_SIZE","currentSrcList","largeSrcList","sculptureButton","imageButton","image","open","constDatas","PATH","TITLE","ALT_IMAGE","init","PAINTING","DRAWING","Error","get","has","model"],"mappings":"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","file":"asyncImage.955b278c.chunk.js","sourcesContent":["// Min image zoom level\nexport const MIN_ZOOM_LEVEL = 0;\n\n// Max image zoom level\nexport const MAX_ZOOM_LEVEL = 300;\n\n// Size ratio between previous and next zoom levels\nexport const ZOOM_RATIO = 1.007;\n\n// How much to increase/decrease the zoom level when the zoom buttons are clicked\nexport const ZOOM_BUTTON_INCREMENT_SIZE = 100;\n\n// Used to judge the amount of horizontal scroll needed to initiate a image move\nexport const WHEEL_MOVE_X_THRESHOLD = 200;\n\n// Used to judge the amount of vertical scroll needed to initiate a zoom action\nexport const WHEEL_MOVE_Y_THRESHOLD = 1;\n\nexport const KEYS = {\n  ESC: 27,\n  LEFT_ARROW: 37,\n  RIGHT_ARROW: 39,\n};\n\n// Actions\nexport const ACTION_NONE = 0;\nexport const ACTION_MOVE = 1;\nexport const ACTION_SWIPE = 2;\nexport const ACTION_PINCH = 3;\nexport const ACTION_ROTATE = 4;\n\n// Events source\nexport const SOURCE_ANY = 0;\nexport const SOURCE_MOUSE = 1;\nexport const SOURCE_TOUCH = 2;\nexport const SOURCE_POINTER = 3;\n\n// Minimal swipe distance\nexport const MIN_SWIPE_DISTANCE = 200;\n\nexport const LIGHTBOX_PADDING = 50;\nexport const LIGHTBOX_MOBILE_PADDING = 10;\n","/* eslint-disable css-modules/no-unused-class */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Modal from 'react-modal';\nimport {\n  translate,\n  getWindowWidth,\n  getWindowHeight,\n  getHighestSafeWindowContext,\n} from '../../../tools/lib/windowUtils';\nimport {\n  KEYS,\n  MIN_ZOOM_LEVEL,\n  MAX_ZOOM_LEVEL,\n  ZOOM_RATIO,\n  WHEEL_MOVE_X_THRESHOLD,\n  WHEEL_MOVE_Y_THRESHOLD,\n  ZOOM_BUTTON_INCREMENT_SIZE,\n  ACTION_NONE,\n  ACTION_MOVE,\n  ACTION_SWIPE,\n  ACTION_PINCH,\n  SOURCE_ANY,\n  SOURCE_MOUSE,\n  SOURCE_TOUCH,\n  SOURCE_POINTER,\n  MIN_SWIPE_DISTANCE,\n} from '../../constants/lightboxConstants';\nimport s from './Lightbox.css';\n\nclass Lightbox extends Component {\n  static isTargetMatchImage(target) {\n    return target && /ril-image-current/.test(target.className);\n  }\n\n  static parseMouseEvent(mouseEvent) {\n    return {\n      id: 'mouse',\n      source: SOURCE_MOUSE,\n      x: parseInt(mouseEvent.clientX, 10),\n      y: parseInt(mouseEvent.clientY, 10),\n    };\n  }\n\n  static parseTouchPointer(touchPointer) {\n    return {\n      id: touchPointer.identifier,\n      source: SOURCE_TOUCH,\n      x: parseInt(touchPointer.clientX, 10),\n      y: parseInt(touchPointer.clientY, 10),\n    };\n  }\n\n  static parsePointerEvent(pointerEvent) {\n    return {\n      id: pointerEvent.pointerId,\n      source: SOURCE_POINTER,\n      x: parseInt(pointerEvent.clientX, 10),\n      y: parseInt(pointerEvent.clientY, 10),\n    };\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      //-----------------------------\n      // Animation\n      //-----------------------------\n\n      // Lightbox is closing\n      // When Lightbox is mounted, if animation is enabled it will open with the reverse of the closing animation\n      isClosing: !props.animationDisabled,\n\n      // Component parts should animate (e.g., when images are moving, or image is being zoomed)\n      shouldAnimate: false,\n\n      //-----------------------------\n      // Zoom settings\n      //-----------------------------\n      // Zoom level of image\n      zoomLevel: MIN_ZOOM_LEVEL,\n\n      //-----------------------------\n      // Image position settings\n      //-----------------------------\n      // Horizontal offset from center\n      offsetX: 0,\n\n      // Vertical offset from center\n      offsetY: 0,\n\n      // image load error for srcType\n      loadErrorStatus: {},\n    };\n\n    this.closeIfClickInner = this.closeIfClickInner.bind(this);\n    this.handleImageDoubleClick = this.handleImageDoubleClick.bind(this);\n    this.handleImageMouseWheel = this.handleImageMouseWheel.bind(this);\n    this.handleKeyInput = this.handleKeyInput.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleOuterMousewheel = this.handleOuterMousewheel.bind(this);\n    this.handleTouchStart = this.handleTouchStart.bind(this);\n    this.handleTouchMove = this.handleTouchMove.bind(this);\n    this.handleTouchEnd = this.handleTouchEnd.bind(this);\n    this.handlePointerEvent = this.handlePointerEvent.bind(this);\n    this.handleCaptionMousewheel = this.handleCaptionMousewheel.bind(this);\n    this.handleWindowResize = this.handleWindowResize.bind(this);\n    this.handleZoomInButtonClick = this.handleZoomInButtonClick.bind(this);\n    this.handleZoomOutButtonClick = this.handleZoomOutButtonClick.bind(this);\n    this.requestClose = this.requestClose.bind(this);\n    this.requestMoveNext = this.requestMoveNext.bind(this);\n    this.requestMovePrev = this.requestMovePrev.bind(this);\n  }\n\n  // eslint-disable-next-line camelcase\n  UNSAFE_componentWillMount() {\n    // Timeouts - always clear it before umount\n    this.timeouts = [];\n\n    // Current action\n    this.currentAction = ACTION_NONE;\n\n    // Events source\n    this.eventsSource = SOURCE_ANY;\n\n    // Empty pointers list\n    this.pointerList = [];\n\n    // Prevent inner close\n    this.preventInnerClose = false;\n    this.preventInnerCloseTimeout = null;\n\n    // Used to disable animation when changing props.mainSrc|nextSrc|prevSrc\n    this.keyPressed = false;\n\n    // Used to store load state / dimensions of images\n    this.imageCache = {};\n\n    // Time the last keydown event was called (used in keyboard action rate limiting)\n    this.lastKeyDownTime = 0;\n\n    // Used for debouncing window resize event\n    this.resizeTimeout = null;\n\n    // Used to determine when actions are triggered by the scroll wheel\n    this.wheelActionTimeout = null;\n    this.resetScrollTimeout = null;\n    this.scrollX = 0;\n    this.scrollY = 0;\n\n    // Used in panning zoomed images\n    this.moveStartX = 0;\n    this.moveStartY = 0;\n    this.moveStartOffsetX = 0;\n    this.moveStartOffsetY = 0;\n\n    // Used to swipe\n    this.swipeStartX = 0;\n    this.swipeStartY = 0;\n    this.swipeEndX = 0;\n    this.swipeEndY = 0;\n\n    // Used to pinch\n    this.pinchTouchList = null;\n    this.pinchDistance = 0;\n\n    // Used to differentiate between images with identical src\n    this.keyCounter = 0;\n\n    // Used to detect a move when all src's remain unchanged (four or more of the same image in a row)\n    this.moveRequested = false;\n\n    if (!this.props.animationDisabled) {\n      // Make opening animation play\n      this.setState({ isClosing: false });\n    }\n  }\n\n  componentDidMount() {\n    // Prevents cross-origin errors when using a cross-origin iframe\n    this.windowContext = getHighestSafeWindowContext();\n\n    this.listeners = {\n      resize: this.handleWindowResize,\n      mouseup: this.handleMouseUp,\n      touchend: this.handleTouchEnd,\n      touchcancel: this.handleTouchEnd,\n      pointerdown: this.handlePointerEvent,\n      pointermove: this.handlePointerEvent,\n      pointerup: this.handlePointerEvent,\n      pointercancel: this.handlePointerEvent,\n    };\n    Object.keys(this.listeners).forEach(type => {\n      this.windowContext.addEventListener(type, this.listeners[type]);\n    });\n\n    this.loadAllImages();\n  }\n\n  // eslint-disable-next-line camelcase\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // Iterate through the source types for prevProps and nextProps to\n    //  determine if any of the sources changed\n    let sourcesChanged = false;\n    const prevSrcDict = {};\n    const nextSrcDict = {};\n    this.getSrcTypes().forEach(srcType => {\n      if (this.props[srcType.name] !== nextProps[srcType.name]) {\n        sourcesChanged = true;\n\n        prevSrcDict[this.props[srcType.name]] = true;\n        nextSrcDict[nextProps[srcType.name]] = true;\n      }\n    });\n\n    if (sourcesChanged || this.moveRequested) {\n      // Reset the loaded state for images not rendered next\n      Object.keys(prevSrcDict).forEach(prevSrc => {\n        if (!(prevSrc in nextSrcDict) && prevSrc in this.imageCache) {\n          this.imageCache[prevSrc].loaded = false;\n        }\n      });\n\n      this.moveRequested = false;\n\n      // Load any new images\n      this.loadAllImages(nextProps);\n    }\n  }\n\n  shouldComponentUpdate() {\n    // Wait for move...\n    return !this.moveRequested;\n  }\n\n  componentWillUnmount() {\n    this.didUnmount = true;\n    Object.keys(this.listeners).forEach(type => {\n      this.windowContext.removeEventListener(type, this.listeners[type]);\n    });\n    this.timeouts.forEach(tid => clearTimeout(tid));\n  }\n\n  setTimeout(func, time) {\n    const id = setTimeout(() => {\n      this.timeouts = this.timeouts.filter(tid => tid !== id);\n      func();\n    }, time);\n    this.timeouts.push(id);\n    return id;\n  }\n\n  // Request to transition to the previous image\n  static getTransform({ x = 0, y = 0, zoom = 1, width, targetWidth }) {\n    let nextX = x;\n    const windowWidth = getWindowWidth();\n    if (width > windowWidth) {\n      nextX += (windowWidth - width) / 2;\n    }\n    const scaleFactor = zoom * (targetWidth / width);\n\n    return {\n      transform: `translate3d(${nextX}px,${y}px,0) scale3d(${scaleFactor},${scaleFactor},1)`,\n    };\n  }\n\n  setPreventInnerClose() {\n    if (this.preventInnerCloseTimeout) {\n      this.clearTimeout(this.preventInnerCloseTimeout);\n    }\n    this.preventInnerClose = true;\n    this.preventInnerCloseTimeout = this.setTimeout(() => {\n      this.preventInnerClose = false;\n      this.preventInnerCloseTimeout = null;\n    }, 100);\n  }\n\n  // Get info for the best suited image to display with the given srcType\n  getBestImageForType(srcType) {\n    let imageSrc = this.props[srcType];\n    let fitSizes = {};\n\n    if (this.isImageLoaded(imageSrc)) {\n      // Use full-size image if available\n      fitSizes = this.getFitSizes(\n        this.imageCache[imageSrc].width,\n        this.imageCache[imageSrc].height,\n      );\n    } else if (this.isImageLoaded(this.props[`${srcType}Thumbnail`])) {\n      // Fall back to using thumbnail if the image has not been loaded\n      imageSrc = this.props[`${srcType}Thumbnail`];\n      fitSizes = this.getFitSizes(\n        this.imageCache[imageSrc].width,\n        this.imageCache[imageSrc].height,\n        true,\n      );\n    } else {\n      return null;\n    }\n\n    return {\n      src: imageSrc,\n      height: this.imageCache[imageSrc].height,\n      width: this.imageCache[imageSrc].width,\n      targetHeight: fitSizes.height,\n      targetWidth: fitSizes.width,\n    };\n  }\n\n  // Get sizing for when an image is larger than the window\n  getFitSizes(width, height, stretch) {\n    const boxSize = this.getLightboxRect();\n    let maxHeight;\n    let maxWidth;\n    if (boxSize.width < this.props.mobileSizeBreakpoint) {\n      maxHeight = boxSize.height - this.props.imageMobilePadding * 2;\n      maxWidth = boxSize.width - this.props.imageMobilePadding * 2;\n    } else {\n      maxHeight = boxSize.height - this.props.imagePadding * 2;\n      maxWidth = boxSize.width - this.props.imagePadding * 2;\n    }\n\n    if (!stretch) {\n      maxHeight = Math.min(maxHeight, height);\n      maxWidth = Math.min(maxWidth, width);\n    }\n\n    const maxRatio = maxWidth / maxHeight;\n    const srcRatio = width / height;\n\n    if (maxRatio > srcRatio) {\n      // height is the constraining dimension of the photo\n      return {\n        width: (width * maxHeight) / height,\n        height: maxHeight,\n      };\n    }\n\n    return {\n      width: maxWidth,\n      height: (height * maxWidth) / width,\n    };\n  }\n\n  getMaxOffsets(zoomLevel = this.state.zoomLevel) {\n    const currentImageInfo = this.getBestImageForType('mainSrc');\n    if (currentImageInfo === null) {\n      return { maxX: 0, minX: 0, maxY: 0, minY: 0 };\n    }\n\n    const boxSize = this.getLightboxRect();\n    const zoomMultiplier = this.getZoomMultiplier(zoomLevel);\n\n    let maxX = 0;\n    if (zoomMultiplier * currentImageInfo.width - boxSize.width < 0) {\n      // if there is still blank space in the X dimension, don't limit except to the opposite edge\n      maxX = (boxSize.width - zoomMultiplier * currentImageInfo.width) / 2;\n    } else {\n      maxX = (zoomMultiplier * currentImageInfo.width - boxSize.width) / 2;\n    }\n\n    let maxY = 0;\n    if (zoomMultiplier * currentImageInfo.height - boxSize.height < 0) {\n      // if there is still blank space in the Y dimension, don't limit except to the opposite edge\n      maxY = (boxSize.height - zoomMultiplier * currentImageInfo.height) / 2;\n    } else {\n      maxY = (zoomMultiplier * currentImageInfo.height - boxSize.height) / 2;\n    }\n\n    return {\n      maxX,\n      maxY,\n      minX: -1 * maxX,\n      minY: -1 * maxY,\n    };\n  }\n\n  // Get image src types\n  getSrcTypes() {\n    return [\n      {\n        name: 'mainSrc',\n        keyEnding: `i${this.keyCounter}`,\n      },\n      {\n        name: 'mainSrcThumbnail',\n        keyEnding: `t${this.keyCounter}`,\n      },\n      {\n        name: 'nextSrc',\n        keyEnding: `i${this.keyCounter + 1}`,\n      },\n      {\n        name: 'nextSrcThumbnail',\n        keyEnding: `t${this.keyCounter + 1}`,\n      },\n      {\n        name: 'prevSrc',\n        keyEnding: `i${this.keyCounter - 1}`,\n      },\n      {\n        name: 'prevSrcThumbnail',\n        keyEnding: `t${this.keyCounter - 1}`,\n      },\n    ];\n  }\n\n  /**\n   * Get sizing when the image is scaled\n   */\n  getZoomMultiplier(zoomLevel = this.state.zoomLevel) {\n    return ZOOM_RATIO ** zoomLevel;\n  }\n\n  /**\n   * Get the size of the lightbox in pixels\n   */\n  getLightboxRect() {\n    if (this.outerEl) {\n      return this.outerEl.getBoundingClientRect();\n    }\n\n    return {\n      width: getWindowWidth(),\n      height: getWindowHeight(),\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n    };\n  }\n\n  clearTimeout(id) {\n    this.timeouts = this.timeouts.filter(tid => tid !== id);\n    clearTimeout(id);\n  }\n\n  // Change zoom level\n  changeZoom(zoomLevel, clientX, clientY) {\n    // Ignore if zoom disabled\n    if (!this.props.enableZoom) {\n      return;\n    }\n\n    // Constrain zoom level to the set bounds\n    const nextZoomLevel = Math.max(\n      MIN_ZOOM_LEVEL,\n      Math.min(MAX_ZOOM_LEVEL, zoomLevel),\n    );\n\n    // Ignore requests that don't change the zoom level\n    if (nextZoomLevel === this.state.zoomLevel) {\n      return;\n    }\n    if (nextZoomLevel === MIN_ZOOM_LEVEL) {\n      // Snap back to center if zoomed all the way out\n      this.setState({\n        zoomLevel: nextZoomLevel,\n        offsetX: 0,\n        offsetY: 0,\n      });\n\n      return;\n    }\n\n    const imageBaseSize = this.getBestImageForType('mainSrc');\n    if (imageBaseSize === null) {\n      return;\n    }\n\n    const currentZoomMultiplier = this.getZoomMultiplier();\n    const nextZoomMultiplier = this.getZoomMultiplier(nextZoomLevel);\n\n    // Default to the center of the image to zoom when no mouse position specified\n    const boxRect = this.getLightboxRect();\n    const pointerX =\n      typeof clientX !== 'undefined'\n        ? clientX - boxRect.left\n        : boxRect.width / 2;\n    const pointerY =\n      typeof clientY !== 'undefined'\n        ? clientY - boxRect.top\n        : boxRect.height / 2;\n\n    const currentImageOffsetX =\n      (boxRect.width - imageBaseSize.width * currentZoomMultiplier) / 2;\n    const currentImageOffsetY =\n      (boxRect.height - imageBaseSize.height * currentZoomMultiplier) / 2;\n\n    const currentImageRealOffsetX = currentImageOffsetX - this.state.offsetX;\n    const currentImageRealOffsetY = currentImageOffsetY - this.state.offsetY;\n\n    const currentPointerXRelativeToImage =\n      (pointerX - currentImageRealOffsetX) / currentZoomMultiplier;\n    const currentPointerYRelativeToImage =\n      (pointerY - currentImageRealOffsetY) / currentZoomMultiplier;\n\n    const nextImageRealOffsetX =\n      pointerX - currentPointerXRelativeToImage * nextZoomMultiplier;\n    const nextImageRealOffsetY =\n      pointerY - currentPointerYRelativeToImage * nextZoomMultiplier;\n\n    const nextImageOffsetX =\n      (boxRect.width - imageBaseSize.width * nextZoomMultiplier) / 2;\n    const nextImageOffsetY =\n      (boxRect.height - imageBaseSize.height * nextZoomMultiplier) / 2;\n\n    let nextOffsetX = nextImageOffsetX - nextImageRealOffsetX;\n    let nextOffsetY = nextImageOffsetY - nextImageRealOffsetY;\n\n    // When zooming out, limit the offset so things don't get left askew\n    if (this.currentAction !== ACTION_PINCH) {\n      const maxOffsets = this.getMaxOffsets();\n      if (this.state.zoomLevel > nextZoomLevel) {\n        nextOffsetX = Math.max(\n          maxOffsets.minX,\n          Math.min(maxOffsets.maxX, nextOffsetX),\n        );\n        nextOffsetY = Math.max(\n          maxOffsets.minY,\n          Math.min(maxOffsets.maxY, nextOffsetY),\n        );\n      }\n    }\n\n    this.setState({\n      zoomLevel: nextZoomLevel,\n      offsetX: nextOffsetX,\n      offsetY: nextOffsetY,\n    });\n  }\n\n  closeIfClickInner(event) {\n    if (\n      !this.preventInnerClose &&\n      event.target.className.search(/\\bril-inner\\b/) > -1\n    ) {\n      this.requestClose(event);\n    }\n  }\n\n  /**\n   * Handle user keyboard actions\n   */\n  handleKeyInput(event) {\n    event.stopPropagation();\n\n    // Ignore key input during animations\n    if (this.isAnimating()) {\n      return;\n    }\n\n    // Allow slightly faster navigation through the images when user presses keys repeatedly\n    if (event.type === 'keyup') {\n      this.lastKeyDownTime -= this.props.keyRepeatKeyupBonus;\n      return;\n    }\n\n    const keyCode = event.which || event.keyCode;\n\n    // Ignore key presses that happen too close to each other (when rapid fire key pressing or holding down the key)\n    // But allow it if it's a lightbox closing action\n    const currentTime = new Date();\n    if (\n      currentTime.getTime() - this.lastKeyDownTime <\n        this.props.keyRepeatLimit &&\n      keyCode !== KEYS.ESC\n    ) {\n      return;\n    }\n    this.lastKeyDownTime = currentTime.getTime();\n\n    switch (keyCode) {\n      // ESC key closes the lightbox\n      case KEYS.ESC:\n        event.preventDefault();\n        this.requestClose(event);\n        break;\n\n      // Left arrow key moves to previous image\n      case KEYS.LEFT_ARROW:\n        if (!this.props.prevSrc) {\n          return;\n        }\n\n        event.preventDefault();\n        this.keyPressed = true;\n        this.requestMovePrev(event);\n        break;\n\n      // Right arrow key moves to next image\n      case KEYS.RIGHT_ARROW:\n        if (!this.props.nextSrc) {\n          return;\n        }\n\n        event.preventDefault();\n        this.keyPressed = true;\n        this.requestMoveNext(event);\n        break;\n\n      default:\n    }\n  }\n\n  /**\n   * Handle a mouse wheel event over the lightbox container\n   */\n  handleOuterMousewheel(event) {\n    // Prevent scrolling of the background\n    event.preventDefault();\n    event.stopPropagation();\n\n    const xThreshold = WHEEL_MOVE_X_THRESHOLD;\n    let actionDelay = 0;\n    const imageMoveDelay = 500;\n\n    this.clearTimeout(this.resetScrollTimeout);\n    this.resetScrollTimeout = this.setTimeout(() => {\n      this.scrollX = 0;\n      this.scrollY = 0;\n    }, 300);\n\n    // Prevent rapid-fire zoom behavior\n    if (this.wheelActionTimeout !== null || this.isAnimating()) {\n      return;\n    }\n\n    if (Math.abs(event.deltaY) < Math.abs(event.deltaX)) {\n      // handle horizontal scrolls with image moves\n      this.scrollY = 0;\n      this.scrollX += event.deltaX;\n\n      const bigLeapX = xThreshold / 2;\n      // If the scroll amount has accumulated sufficiently, or a large leap was taken\n      if (this.scrollX >= xThreshold || event.deltaX >= bigLeapX) {\n        // Scroll right moves to next\n        this.requestMoveNext(event);\n        actionDelay = imageMoveDelay;\n        this.scrollX = 0;\n      } else if (\n        this.scrollX <= -1 * xThreshold ||\n        event.deltaX <= -1 * bigLeapX\n      ) {\n        // Scroll left moves to previous\n        this.requestMovePrev(event);\n        actionDelay = imageMoveDelay;\n        this.scrollX = 0;\n      }\n    }\n\n    // Allow successive actions after the set delay\n    if (actionDelay !== 0) {\n      this.wheelActionTimeout = this.setTimeout(() => {\n        this.wheelActionTimeout = null;\n      }, actionDelay);\n    }\n  }\n\n  handleImageMouseWheel(event) {\n    event.preventDefault();\n    const yThreshold = WHEEL_MOVE_Y_THRESHOLD;\n\n    if (Math.abs(event.deltaY) >= Math.abs(event.deltaX)) {\n      event.stopPropagation();\n      // If the vertical scroll amount was large enough, perform a zoom\n      if (Math.abs(event.deltaY) < yThreshold) {\n        return;\n      }\n\n      this.scrollX = 0;\n      this.scrollY += event.deltaY;\n\n      this.changeZoom(\n        this.state.zoomLevel - event.deltaY,\n        event.clientX,\n        event.clientY,\n      );\n    }\n  }\n\n  /**\n   * Handle a double click on the current image\n   */\n  handleImageDoubleClick(event) {\n    if (this.state.zoomLevel > MIN_ZOOM_LEVEL) {\n      // A double click when zoomed in zooms all the way out\n      this.changeZoom(MIN_ZOOM_LEVEL, event.clientX, event.clientY);\n    } else {\n      // A double click when zoomed all the way out zooms in\n      this.changeZoom(\n        this.state.zoomLevel + ZOOM_BUTTON_INCREMENT_SIZE,\n        event.clientX,\n        event.clientY,\n      );\n    }\n  }\n\n  shouldHandleEvent(source) {\n    if (this.eventsSource === source) {\n      return true;\n    }\n    if (this.eventsSource === SOURCE_ANY) {\n      this.eventsSource = source;\n      return true;\n    }\n    switch (source) {\n      case SOURCE_MOUSE:\n        return false;\n      case SOURCE_TOUCH:\n        this.eventsSource = SOURCE_TOUCH;\n        this.filterPointersBySource();\n        return true;\n      case SOURCE_POINTER:\n        if (this.eventsSource === SOURCE_MOUSE) {\n          this.eventsSource = SOURCE_POINTER;\n          this.filterPointersBySource();\n          return true;\n        }\n        return false;\n      default:\n        return false;\n    }\n  }\n\n  addPointer(pointer) {\n    this.pointerList.push(pointer);\n  }\n\n  removePointer(pointer) {\n    this.pointerList = this.pointerList.filter(({ id }) => id !== pointer.id);\n  }\n\n  filterPointersBySource() {\n    this.pointerList = this.pointerList.filter(\n      ({ source }) => source === this.eventsSource,\n    );\n  }\n\n  handleMouseDown(event) {\n    if (\n      this.shouldHandleEvent(SOURCE_MOUSE) &&\n      Lightbox.isTargetMatchImage(event.target)\n    ) {\n      this.addPointer(Lightbox.parseMouseEvent(event));\n      this.multiPointerStart(event);\n    }\n  }\n\n  handleMouseMove(event) {\n    if (this.shouldHandleEvent(SOURCE_MOUSE)) {\n      this.multiPointerMove(event, [Lightbox.parseMouseEvent(event)]);\n    }\n  }\n\n  handleMouseUp(event) {\n    if (this.shouldHandleEvent(SOURCE_MOUSE)) {\n      this.removePointer(Lightbox.parseMouseEvent(event));\n      this.multiPointerEnd(event);\n    }\n  }\n\n  handlePointerEvent(event) {\n    if (this.shouldHandleEvent(SOURCE_POINTER)) {\n      switch (event.type) {\n        case 'pointerdown':\n          if (Lightbox.isTargetMatchImage(event.target)) {\n            this.addPointer(Lightbox.parsePointerEvent(event));\n            this.multiPointerStart(event);\n          }\n          break;\n        case 'pointermove':\n          this.multiPointerMove(event, [Lightbox.parsePointerEvent(event)]);\n          break;\n        case 'pointerup':\n        case 'pointercancel':\n          this.removePointer(Lightbox.parsePointerEvent(event));\n          this.multiPointerEnd(event);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  handleTouchStart(event) {\n    if (\n      this.shouldHandleEvent(SOURCE_TOUCH) &&\n      Lightbox.isTargetMatchImage(event.target)\n    ) {\n      [].forEach.call(event.changedTouches, eventTouch =>\n        this.addPointer(Lightbox.parseTouchPointer(eventTouch)),\n      );\n      this.multiPointerStart(event);\n    }\n  }\n\n  handleTouchMove(event) {\n    if (this.shouldHandleEvent(SOURCE_TOUCH)) {\n      this.multiPointerMove(\n        event,\n        [].map.call(event.changedTouches, eventTouch =>\n          Lightbox.parseTouchPointer(eventTouch),\n        ),\n      );\n    }\n  }\n\n  handleTouchEnd(event) {\n    if (this.shouldHandleEvent(SOURCE_TOUCH)) {\n      [].map.call(event.changedTouches, touch =>\n        this.removePointer(Lightbox.parseTouchPointer(touch)),\n      );\n      this.multiPointerEnd(event);\n    }\n  }\n\n  decideMoveOrSwipe(pointer) {\n    if (this.state.zoomLevel <= MIN_ZOOM_LEVEL) {\n      this.handleSwipeStart(pointer);\n    } else {\n      this.handleMoveStart(pointer);\n    }\n  }\n\n  multiPointerStart(event) {\n    this.handleEnd(null);\n    switch (this.pointerList.length) {\n      case 1: {\n        event.preventDefault();\n        this.decideMoveOrSwipe(this.pointerList[0]);\n        break;\n      }\n      case 2: {\n        event.preventDefault();\n        this.handlePinchStart(this.pointerList);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  multiPointerMove(event, pointerList) {\n    switch (this.currentAction) {\n      case ACTION_MOVE: {\n        event.preventDefault();\n        this.handleMove(pointerList[0]);\n        break;\n      }\n      case ACTION_SWIPE: {\n        event.preventDefault();\n        this.handleSwipe(pointerList[0]);\n        break;\n      }\n      case ACTION_PINCH: {\n        event.preventDefault();\n        this.handlePinch(pointerList);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  multiPointerEnd(event) {\n    if (this.currentAction !== ACTION_NONE) {\n      this.setPreventInnerClose();\n      this.handleEnd(event);\n    }\n    switch (this.pointerList.length) {\n      case 0: {\n        this.eventsSource = SOURCE_ANY;\n        break;\n      }\n      case 1: {\n        event.preventDefault();\n        this.decideMoveOrSwipe(this.pointerList[0]);\n        break;\n      }\n      case 2: {\n        event.preventDefault();\n        this.handlePinchStart(this.pointerList);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  handleEnd(event) {\n    switch (this.currentAction) {\n      case ACTION_MOVE:\n        this.handleMoveEnd(event);\n        break;\n      case ACTION_SWIPE:\n        this.handleSwipeEnd(event);\n        break;\n      case ACTION_PINCH:\n        this.handlePinchEnd(event);\n        break;\n      default:\n        break;\n    }\n  }\n\n  // Handle move start over the lightbox container\n  // This happens:\n  // - On a mouseDown event\n  // - On a touchstart event\n  handleMoveStart({ x: clientX, y: clientY }) {\n    if (!this.props.enableZoom) {\n      return;\n    }\n    this.currentAction = ACTION_MOVE;\n    this.moveStartX = clientX;\n    this.moveStartY = clientY;\n    this.moveStartOffsetX = this.state.offsetX;\n    this.moveStartOffsetY = this.state.offsetY;\n  }\n\n  // Handle dragging over the lightbox container\n  // This happens:\n  // - After a mouseDown and before a mouseUp event\n  // - After a touchstart and before a touchend event\n  handleMove({ x: clientX, y: clientY }) {\n    const newOffsetX = this.moveStartX - clientX + this.moveStartOffsetX;\n    const newOffsetY = this.moveStartY - clientY + this.moveStartOffsetY;\n    if (\n      this.state.offsetX !== newOffsetX ||\n      this.state.offsetY !== newOffsetY\n    ) {\n      this.setState({\n        offsetX: newOffsetX,\n        offsetY: newOffsetY,\n      });\n    }\n  }\n\n  handleMoveEnd() {\n    this.currentAction = ACTION_NONE;\n    this.moveStartX = 0;\n    this.moveStartY = 0;\n    this.moveStartOffsetX = 0;\n    this.moveStartOffsetY = 0;\n    // Snap image back into frame if outside max offset range\n    const maxOffsets = this.getMaxOffsets();\n    const nextOffsetX = Math.max(\n      maxOffsets.minX,\n      Math.min(maxOffsets.maxX, this.state.offsetX),\n    );\n    const nextOffsetY = Math.max(\n      maxOffsets.minY,\n      Math.min(maxOffsets.maxY, this.state.offsetY),\n    );\n    if (\n      nextOffsetX !== this.state.offsetX ||\n      nextOffsetY !== this.state.offsetY\n    ) {\n      this.setState({\n        offsetX: nextOffsetX,\n        offsetY: nextOffsetY,\n        shouldAnimate: true,\n      });\n      this.setTimeout(() => {\n        this.setState({ shouldAnimate: false });\n      }, this.props.animationDuration);\n    }\n  }\n\n  handleSwipeStart({ x: clientX, y: clientY }) {\n    this.currentAction = ACTION_SWIPE;\n    this.swipeStartX = clientX;\n    this.swipeStartY = clientY;\n    this.swipeEndX = clientX;\n    this.swipeEndY = clientY;\n  }\n\n  handleSwipe({ x: clientX, y: clientY }) {\n    this.swipeEndX = clientX;\n    this.swipeEndY = clientY;\n  }\n\n  handleSwipeEnd(event) {\n    const xDiff = this.swipeEndX - this.swipeStartX;\n    const xDiffAbs = Math.abs(xDiff);\n    const yDiffAbs = Math.abs(this.swipeEndY - this.swipeStartY);\n\n    this.currentAction = ACTION_NONE;\n    this.swipeStartX = 0;\n    this.swipeStartY = 0;\n    this.swipeEndX = 0;\n    this.swipeEndY = 0;\n\n    if (!event || this.isAnimating() || xDiffAbs < yDiffAbs * 1.5) {\n      return;\n    }\n\n    if (xDiffAbs < MIN_SWIPE_DISTANCE) {\n      const boxRect = this.getLightboxRect();\n      if (xDiffAbs < boxRect.width / 4) {\n        return;\n      }\n    }\n\n    if (xDiff > 0 && this.props.prevSrc) {\n      event.preventDefault();\n      this.requestMovePrev();\n    } else if (xDiff < 0 && this.props.nextSrc) {\n      event.preventDefault();\n      this.requestMoveNext();\n    }\n  }\n\n  calculatePinchDistance([a, b] = this.pinchTouchList) {\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\n  }\n\n  calculatePinchCenter([a, b] = this.pinchTouchList) {\n    return {\n      x: a.x - (a.x - b.x) / 2,\n      y: a.y - (a.y - b.y) / 2,\n    };\n  }\n\n  handlePinchStart(pointerList) {\n    if (!this.props.enableZoom) {\n      return;\n    }\n    this.currentAction = ACTION_PINCH;\n    this.pinchTouchList = pointerList.map(({ id, x, y }) => ({ id, x, y }));\n    this.pinchDistance = this.calculatePinchDistance();\n  }\n\n  handlePinch(pointerList) {\n    this.pinchTouchList = this.pinchTouchList.map(oldPointer => {\n      for (let i = 0; i < pointerList.length; i += 1) {\n        if (pointerList[i].id === oldPointer.id) {\n          return pointerList[i];\n        }\n      }\n\n      return oldPointer;\n    });\n\n    const newDistance = this.calculatePinchDistance();\n\n    const zoomLevel = this.state.zoomLevel + newDistance - this.pinchDistance;\n\n    this.pinchDistance = newDistance;\n    const { x: clientX, y: clientY } = this.calculatePinchCenter(\n      this.pinchTouchList,\n    );\n    this.changeZoom(zoomLevel, clientX, clientY);\n  }\n\n  handlePinchEnd() {\n    this.currentAction = ACTION_NONE;\n    this.pinchTouchList = null;\n    this.pinchDistance = 0;\n  }\n\n  // Handle the window resize event\n  handleWindowResize() {\n    this.clearTimeout(this.resizeTimeout);\n    this.resizeTimeout = this.setTimeout(this.forceUpdate.bind(this), 100);\n  }\n\n  handleZoomInButtonClick() {\n    const nextZoomLevel = this.state.zoomLevel + ZOOM_BUTTON_INCREMENT_SIZE;\n    this.changeZoom(nextZoomLevel);\n    if (nextZoomLevel === MAX_ZOOM_LEVEL) {\n      this.zoomOutBtn.focus();\n    }\n  }\n\n  handleZoomOutButtonClick() {\n    const nextZoomLevel = this.state.zoomLevel - ZOOM_BUTTON_INCREMENT_SIZE;\n    this.changeZoom(nextZoomLevel);\n    if (nextZoomLevel === MIN_ZOOM_LEVEL) {\n      this.zoomInBtn.focus();\n    }\n  }\n\n  handleCaptionMousewheel(event) {\n    event.stopPropagation();\n\n    if (!this.caption) {\n      return;\n    }\n\n    const { height } = this.caption.getBoundingClientRect();\n    const { scrollHeight, scrollTop } = this.caption;\n    if (\n      (event.deltaY > 0 && height + scrollTop >= scrollHeight) ||\n      (event.deltaY < 0 && scrollTop <= 0)\n    ) {\n      event.preventDefault();\n    }\n  }\n\n  // Detach key and mouse input events\n  isAnimating() {\n    return this.state.shouldAnimate || this.state.isClosing;\n  }\n\n  // Check if image is loaded\n  isImageLoaded(imageSrc) {\n    return (\n      imageSrc &&\n      imageSrc in this.imageCache &&\n      this.imageCache[imageSrc].loaded\n    );\n  }\n\n  // Load image from src and call callback with image width and height on load\n  loadImage(srcType, imageSrc, done) {\n    // Return the image info if it is already cached\n    if (this.isImageLoaded(imageSrc)) {\n      this.setTimeout(() => {\n        done();\n      }, 1);\n      return;\n    }\n\n    const inMemoryImage = new global.Image();\n\n    if (this.props.imageCrossOrigin) {\n      inMemoryImage.crossOrigin = this.props.imageCrossOrigin;\n    }\n\n    inMemoryImage.onerror = errorEvent => {\n      this.props.onImageLoadError(imageSrc, srcType, errorEvent);\n\n      // failed to load so set the state loadErrorStatus\n      this.setState(prevState => ({\n        loadErrorStatus: { ...prevState.loadErrorStatus, [srcType]: true },\n      }));\n\n      done(errorEvent);\n    };\n\n    inMemoryImage.onload = () => {\n      this.props.onImageLoad(imageSrc, srcType, inMemoryImage);\n\n      this.imageCache[imageSrc] = {\n        loaded: true,\n        width: inMemoryImage.width,\n        height: inMemoryImage.height,\n      };\n\n      done();\n    };\n\n    inMemoryImage.src = imageSrc;\n  }\n\n  // Load all images and their thumbnails\n  loadAllImages(props = this.props) {\n    const generateLoadDoneCallback = (srcType, imageSrc) => err => {\n      // Give up showing image on error\n      if (err) {\n        return;\n      }\n\n      // Don't rerender if the src is not the same as when the load started\n      // or if the component has unmounted\n      if (this.props[srcType] !== imageSrc || this.didUnmount) {\n        return;\n      }\n\n      // Force rerender with the new image\n      this.forceUpdate();\n    };\n\n    // Load the images\n    this.getSrcTypes().forEach(srcType => {\n      const type = srcType.name;\n\n      // there is no error when we try to load it initially\n      if (props[type] && this.state.loadErrorStatus[type]) {\n        this.setState(prevState => ({\n          loadErrorStatus: { ...prevState.loadErrorStatus, [type]: false },\n        }));\n      }\n\n      // Load unloaded images\n      if (props[type] && !this.isImageLoaded(props[type])) {\n        this.loadImage(\n          type,\n          props[type],\n          generateLoadDoneCallback(type, props[type]),\n        );\n      }\n    });\n  }\n\n  // Request that the lightbox be closed\n  requestClose(event) {\n    // Call the parent close request\n    const closeLightbox = () => this.props.onCloseRequest(event);\n\n    if (\n      this.props.animationDisabled ||\n      (event.type === 'keydown' && !this.props.animationOnKeyInput)\n    ) {\n      // No animation\n      closeLightbox();\n      return;\n    }\n\n    // With animation\n    // Start closing animation\n    this.setState({ isClosing: true });\n\n    // Perform the actual closing at the end of the animation\n    this.setTimeout(closeLightbox, this.props.animationDuration);\n  }\n\n  requestMove(direction, event) {\n    // Reset the zoom level on image move\n    const nextState = {\n      zoomLevel: MIN_ZOOM_LEVEL,\n      offsetX: 0,\n      offsetY: 0,\n    };\n\n    // Enable animated states\n    if (\n      !this.props.animationDisabled &&\n      (!this.keyPressed || this.props.animationOnKeyInput)\n    ) {\n      nextState.shouldAnimate = true;\n      this.setTimeout(\n        () => this.setState({ shouldAnimate: false }),\n        this.props.animationDuration,\n      );\n    }\n    this.keyPressed = false;\n\n    this.moveRequested = true;\n\n    if (direction === 'prev') {\n      this.keyCounter -= 1;\n      this.setState(nextState);\n      this.props.onMovePrevRequest(event);\n    } else {\n      this.keyCounter += 1;\n      this.setState(nextState);\n      this.props.onMoveNextRequest(event);\n    }\n  }\n\n  // Request to transition to the next image\n  requestMoveNext(event) {\n    this.requestMove('next', event);\n  }\n\n  // Request to transition to the previous image\n  requestMovePrev(event) {\n    this.requestMove('prev', event);\n  }\n\n  render() {\n    const {\n      animationDisabled,\n      animationDuration,\n      clickOutsideToClose,\n      discourageDownloads,\n      enableZoom,\n      imageTitle,\n      nextSrc,\n      prevSrc,\n      toolbarButtons,\n      reactModalStyle,\n      onAfterOpen,\n      imageCrossOrigin,\n      reactModalProps,\n    } = this.props;\n    const {\n      zoomLevel,\n      offsetX,\n      offsetY,\n      isClosing,\n      loadErrorStatus,\n    } = this.state;\n\n    const boxSize = this.getLightboxRect();\n    let transitionStyle = {};\n\n    // Transition settings for sliding animations\n    if (!animationDisabled && this.isAnimating()) {\n      transitionStyle = {\n        ...transitionStyle,\n        transition: `transform ${animationDuration}ms`,\n      };\n    }\n\n    // Key endings to differentiate between images with the same src\n    const keyEndings = {};\n    this.getSrcTypes().forEach(({ name, keyEnding }) => {\n      keyEndings[name] = keyEnding;\n    });\n\n    // Images to be displayed\n    const images = [];\n    const addImage = (srcType, imageClass, transforms) => {\n      // Ignore types that have no source defined for their full size image\n      if (!this.props[srcType]) {\n        return;\n      }\n      const bestImageInfo = this.getBestImageForType(srcType);\n\n      const imageStyle = {\n        ...transitionStyle,\n        ...Lightbox.getTransform({\n          ...transforms,\n          ...bestImageInfo,\n        }),\n      };\n\n      if (zoomLevel > MIN_ZOOM_LEVEL) {\n        imageStyle.cursor = 'move';\n      }\n\n      // support IE 9 and 11\n      const hasTrueValue = object =>\n        Object.keys(object).some(key => object[key]);\n\n      // when error on one of the loads then push custom error stuff\n      if (bestImageInfo === null && hasTrueValue(loadErrorStatus)) {\n        images.push(\n          <div\n            className={`${imageClass} ${s.ril__image}`}\n            style={imageStyle}\n            key={this.props[srcType] + keyEndings[srcType]}\n          >\n            <div className=\"ril__errorContainer\">\n              {this.props.imageLoadErrorMessage}\n            </div>\n          </div>,\n        );\n\n        return;\n      }\n      if (bestImageInfo === null) {\n        const loadingIcon = (\n          <div\n            className={`${s.ril__loadingCircle} ${s.ril__loadingContainer__icon}`}\n          >\n            {[...new Array(12)].map((_, index) => (\n              <div\n                // eslint-disable-next-line react/no-array-index-key\n                key={index}\n                className={s.ril__loadingCirclePoint}\n              />\n            ))}\n          </div>\n        );\n\n        // Fall back to loading icon if the thumbnail has not been loaded\n        images.push(\n          <div\n            className={`${imageClass} ${s.ril__image}`}\n            style={imageStyle}\n            key={this.props[srcType] + keyEndings[srcType]}\n          >\n            <div className={s.ril__loadingContainer}>{loadingIcon}</div>\n          </div>,\n        );\n\n        return;\n      }\n\n      const imageSrc = bestImageInfo.src;\n      if (discourageDownloads) {\n        imageStyle.backgroundImage = `url('${imageSrc}')`;\n        images.push(\n          <div\n            className={`${imageClass} ${s.ril__image} ${s.ril__imageDiscourager}`}\n            onDoubleClick={this.handleImageDoubleClick}\n            onWheel={this.handleImageMouseWheel}\n            style={imageStyle}\n            key={imageSrc + keyEndings[srcType]}\n          >\n            <div className={s.ril__downloadBlocker} />\n          </div>,\n        );\n      } else {\n        images.push(\n          <img\n            /* eslint-disable-next-line react/jsx-props-no-spreading */\n            {...(imageCrossOrigin ? { crossOrigin: imageCrossOrigin } : {})}\n            className={`${imageClass} ${s.ril__image}`}\n            onDoubleClick={this.handleImageDoubleClick}\n            onWheel={this.handleImageMouseWheel}\n            onDragStart={e => e.preventDefault()}\n            style={imageStyle}\n            src={imageSrc}\n            key={imageSrc + keyEndings[srcType]}\n            alt={\n              typeof imageTitle === 'string' ? imageTitle : translate('Image')\n            }\n            draggable={false}\n          />,\n        );\n      }\n    };\n\n    const zoomMultiplier = this.getZoomMultiplier();\n    // Next Image (displayed on the right)\n    addImage('nextSrc', 'ril-image-next ril__imageNext', {\n      x: boxSize.width,\n    });\n    // Main Image\n    addImage('mainSrc', 'ril-image-current', {\n      x: -1 * offsetX,\n      y: -1 * offsetY,\n      zoom: zoomMultiplier,\n    });\n    // Previous Image (displayed on the left)\n\n    addImage('prevSrc', 'ril-image-prev ril__imagePrev', {\n      x: -1 * boxSize.width,\n    });\n\n    const modalStyle = {\n      overlay: {\n        zIndex: 1000,\n        backgroundColor: 'transparent',\n        // eslint-disable-next-line react/prop-types\n        ...reactModalStyle.overlay, // Allow style overrides via props\n      },\n      content: {\n        backgroundColor: 'transparent',\n        overflow: 'hidden', // Needed, otherwise keyboard shortcuts scroll the page\n        border: 'none',\n        borderRadius: 0,\n        padding: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        // eslint-disable-next-line react/prop-types\n        ...reactModalStyle.content, // Allow style overrides via props\n      },\n    };\n\n    return (\n      <Modal\n        isOpen\n        onRequestClose={clickOutsideToClose ? this.requestClose : undefined}\n        onAfterOpen={() => {\n          // Focus on the div with key handlers\n          if (this.outerEl) {\n            this.outerEl.focus();\n          }\n\n          onAfterOpen();\n        }}\n        style={modalStyle}\n        contentLabel={translate('Lightbox')}\n        appElement={\n          typeof global.window !== 'undefined'\n            ? global.window.document.body\n            : undefined\n        }\n        /* eslint-disable-next-line react/jsx-props-no-spreading */\n        {...reactModalProps}\n      >\n        <div // eslint-disable-line jsx-a11y/no-static-element-interactions\n          // Floating modal with closing animations\n          className={`${s.ril__outer} ${s.ril__outerAnimating} ${\n            this.props.wrapperClassName\n          } ${isClosing ? `${s.ril__outerClosing}` : ''}`}\n          style={{\n            transition: `opacity ${animationDuration}ms`,\n            animationDuration: `${animationDuration}ms`,\n            animationDirection: isClosing ? 'normal' : 'reverse',\n          }}\n          ref={el => {\n            this.outerEl = el;\n          }}\n          onWheel={this.handleOuterMousewheel}\n          onMouseMove={this.handleMouseMove}\n          onMouseDown={this.handleMouseDown}\n          onTouchStart={this.handleTouchStart}\n          onTouchMove={this.handleTouchMove}\n          tabIndex=\"-1\" // Enables key handlers on div\n          onKeyDown={this.handleKeyInput}\n          onKeyUp={this.handleKeyInput}\n        >\n          <div // eslint-disable-line jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events\n            className={`ril-inner ${s.ril__inner}`}\n            onClick={clickOutsideToClose ? this.closeIfClickInner : undefined}\n          >\n            {images}\n          </div>\n          {prevSrc && (\n            <button // Move to previous image button\n              type=\"button\"\n              className={`${s.ril__navButtons} ${s.ril__navButtonPrev}`}\n              key=\"prev\"\n              aria-label={this.props.prevLabel}\n              onClick={!this.isAnimating() ? this.requestMovePrev : undefined} // Ignore clicks during animation\n            />\n          )}\n\n          {nextSrc && (\n            <button // Move to next image button\n              type=\"button\"\n              className={`${s.ril__navButtons} ${s.ril__navButtonNext}`}\n              key=\"next\"\n              aria-label={this.props.nextLabel}\n              onClick={!this.isAnimating() ? this.requestMoveNext : undefined} // Ignore clicks during animation\n            />\n          )}\n\n          <div // Lightbox toolbar\n            className={s.ril__toolbar}\n          >\n            <ul className={`${s.ril__toolbarSide} ${s.ril__toolbarLeftSide}`}>\n              <li className={s.ril__toolbarItem}>\n                <span className={s.ril__toolbarItemChild}>{imageTitle}</span>\n              </li>\n            </ul>\n\n            <ul className={`${s.ril__toolbarSide} ${s.ril__toolbarRightSide}`}>\n              {toolbarButtons &&\n                toolbarButtons.map((button, i) => (\n                  <li key={`button_${i + 1}`} className={s.ril__toolbarItem}>\n                    {button}\n                  </li>\n                ))}\n\n              {enableZoom && (\n                <li className={s.ril__toolbarItem}>\n                  <button // Lightbox zoom in button\n                    type=\"button\"\n                    key=\"zoom-in\"\n                    aria-label={this.props.zoomInLabel}\n                    className={[\n                      `${s.ril__toolbarItemChild}`,\n                      `${s.ril__builtinButton}`,\n                      `${s.ril__zoomInButton}`,\n                      ...(zoomLevel === MAX_ZOOM_LEVEL\n                        ? [`${s.ril__builtinButtonDisabled}`]\n                        : []),\n                    ].join(' ')}\n                    ref={el => {\n                      this.zoomInBtn = el;\n                    }}\n                    disabled={\n                      this.isAnimating() || zoomLevel === MAX_ZOOM_LEVEL\n                    }\n                    onClick={\n                      !this.isAnimating() && zoomLevel !== MAX_ZOOM_LEVEL\n                        ? this.handleZoomInButtonClick\n                        : undefined\n                    }\n                  />\n                </li>\n              )}\n\n              {enableZoom && (\n                <li className={s.ril__toolbarItem}>\n                  <button // Lightbox zoom out button\n                    type=\"button\"\n                    key=\"zoom-out\"\n                    aria-label={this.props.zoomOutLabel}\n                    className={[\n                      `${s.ril__toolbarItemChild}`,\n                      `${s.ril__builtinButton}`,\n                      `${s.ril__zoomOutButton}`,\n                      ...(zoomLevel === MIN_ZOOM_LEVEL\n                        ? [s.ril__builtinButtonDisabled]\n                        : []),\n                    ].join(' ')}\n                    ref={el => {\n                      this.zoomOutBtn = el;\n                    }}\n                    disabled={\n                      this.isAnimating() || zoomLevel === MIN_ZOOM_LEVEL\n                    }\n                    onClick={\n                      !this.isAnimating() && zoomLevel !== MIN_ZOOM_LEVEL\n                        ? this.handleZoomOutButtonClick\n                        : undefined\n                    }\n                  />\n                </li>\n              )}\n\n              <li className={s.ril__toolbarItem}>\n                <button // Lightbox close button\n                  type=\"button\"\n                  key=\"close\"\n                  aria-label={this.props.closeLabel}\n                  className={`${s.ril__toolbarItemChild} ${s.ril__builtinButton} ${s.ril__closeButton}`}\n                  onClick={!this.isAnimating() ? this.requestClose : undefined} // Ignore clicks during animation\n                />\n              </li>\n            </ul>\n          </div>\n\n          {this.props.imageCaption && (\n            // eslint-disable-next-line jsx-a11y/no-static-element-interactions\n            <div // Image caption`\n              onWheel={this.handleCaptionMousewheel}\n              onMouseDown={event => event.stopPropagation()}\n              className={s.ril__caption}\n              ref={el => {\n                this.caption = el;\n              }}\n            >\n              <div className={s.ril__captionContent}>\n                {this.props.imageCaption}\n              </div>\n            </div>\n          )}\n        </div>\n      </Modal>\n    );\n  }\n}\n\nLightbox.propTypes = {\n  //-----------------------------\n  // Image sources\n  //-----------------------------\n\n  // Main display image url\n  mainSrc: PropTypes.string.isRequired, // eslint-disable-line react/no-unused-prop-types\n\n  // Previous display image url (displayed to the left)\n  // If left undefined, movePrev actions will not be performed, and the button not displayed\n  prevSrc: PropTypes.string,\n\n  // Next display image url (displayed to the right)\n  // If left undefined, moveNext actions will not be performed, and the button not displayed\n  nextSrc: PropTypes.string,\n\n  //-----------------------------\n  // Image thumbnail sources\n  //-----------------------------\n\n  // Thumbnail image url corresponding to props.mainSrc\n  mainSrcThumbnail: PropTypes.string, // eslint-disable-line react/no-unused-prop-types\n\n  // Thumbnail image url corresponding to props.prevSrc\n  prevSrcThumbnail: PropTypes.string, // eslint-disable-line react/no-unused-prop-types\n\n  // Thumbnail image url corresponding to props.nextSrc\n  nextSrcThumbnail: PropTypes.string, // eslint-disable-line react/no-unused-prop-types\n\n  //-----------------------------\n  // Event Handlers\n  //-----------------------------\n\n  // Close window event\n  // Should change the parent state such that the lightbox is not rendered\n  onCloseRequest: PropTypes.func.isRequired,\n\n  // Move to previous image event\n  // Should change the parent state such that props.prevSrc becomes props.mainSrc,\n  //  props.mainSrc becomes props.nextSrc, etc.\n  onMovePrevRequest: PropTypes.func,\n\n  // Move to next image event\n  // Should change the parent state such that props.nextSrc becomes props.mainSrc,\n  //  props.mainSrc becomes props.prevSrc, etc.\n  onMoveNextRequest: PropTypes.func,\n\n  // Called when an image fails to load\n  // (imageSrc: string, srcType: string, errorEvent: object): void\n  onImageLoadError: PropTypes.func,\n\n  // Called when image successfully loads\n  onImageLoad: PropTypes.func,\n\n  // Open window event\n  onAfterOpen: PropTypes.func,\n\n  //-----------------------------\n  // Download discouragement settings\n  //-----------------------------\n\n  // Enable download discouragement (prevents [right-click -> Save Image As...])\n  discourageDownloads: PropTypes.bool,\n\n  //-----------------------------\n  // Animation settings\n  //-----------------------------\n\n  // Disable all animation\n  animationDisabled: PropTypes.bool,\n\n  // Disable animation on actions performed with keyboard shortcuts\n  animationOnKeyInput: PropTypes.bool,\n\n  // Animation duration (ms)\n  animationDuration: PropTypes.number,\n\n  //-----------------------------\n  // Keyboard shortcut settings\n  //-----------------------------\n\n  // Required interval of time (ms) between key actions\n  // (prevents excessively fast navigation of images)\n  keyRepeatLimit: PropTypes.number,\n\n  // Amount of time (ms) restored after each keyup\n  // (makes rapid key presses slightly faster than holding down the key to navigate images)\n  keyRepeatKeyupBonus: PropTypes.number,\n\n  //-----------------------------\n  // Image info\n  //-----------------------------\n\n  // Image title\n  imageTitle: PropTypes.node,\n\n  // Image caption\n  imageCaption: PropTypes.node,\n\n  // Optional crossOrigin attribute\n  imageCrossOrigin: PropTypes.string,\n\n  //-----------------------------\n  // Lightbox style\n  //-----------------------------\n\n  // Set z-index style, etc., for the parent react-modal (format: https://github.com/reactjs/react-modal#styles )\n  reactModalStyle: PropTypes.shape({}),\n\n  // Padding (px) between the edge of the window and the lightbox\n  imagePadding: PropTypes.number,\n\n  // Padding (px) between the edge of the window and the lightbox for small screen\n  imageMobilePadding: PropTypes.number,\n\n  // screen size (px) for mobile padding\n  mobileSizeBreakpoint: PropTypes.number,\n\n  wrapperClassName: PropTypes.string,\n\n  //-----------------------------\n  // Other\n  //-----------------------------\n\n  // Array of custom toolbar buttons\n  toolbarButtons: PropTypes.arrayOf(PropTypes.node),\n\n  // When true, clicks outside of the image close the lightbox\n  clickOutsideToClose: PropTypes.bool,\n\n  // Set to false to disable zoom functionality and hide zoom buttons\n  enableZoom: PropTypes.bool,\n\n  // Override props set on react-modal (https://github.com/reactjs/react-modal)\n  reactModalProps: PropTypes.shape({}),\n\n  // Aria-labels\n  nextLabel: PropTypes.string,\n  prevLabel: PropTypes.string,\n  zoomInLabel: PropTypes.string,\n  zoomOutLabel: PropTypes.string,\n  closeLabel: PropTypes.string,\n\n  imageLoadErrorMessage: PropTypes.node,\n};\n\nLightbox.defaultProps = {\n  imageTitle: null,\n  imageCaption: null,\n  toolbarButtons: null,\n  reactModalProps: {},\n  animationDisabled: false,\n  animationDuration: 300,\n  animationOnKeyInput: false,\n  clickOutsideToClose: true,\n  closeLabel: 'Fermer',\n  discourageDownloads: false,\n  enableZoom: true,\n  imagePadding: 10,\n  imageMobilePadding: 100,\n  mobileSizeBreakpoint: 768,\n  imageCrossOrigin: null,\n  keyRepeatKeyupBonus: 40,\n  keyRepeatLimit: 180,\n  mainSrcThumbnail: null,\n  nextLabel: 'Image suivante',\n  nextSrc: null,\n  nextSrcThumbnail: null,\n  onAfterOpen: () => {},\n  onImageLoadError: () => {},\n  onImageLoad: () => {},\n  onMoveNextRequest: () => {},\n  onMovePrevRequest: () => {},\n  prevLabel: 'Image précédente',\n  prevSrc: null,\n  prevSrcThumbnail: null,\n  reactModalStyle: {},\n  wrapperClassName: '',\n  zoomInLabel: 'Zoom in',\n  zoomOutLabel: 'Zoom out',\n  imageLoadErrorMessage: \"Erreur de chargement de l'image\",\n};\n\nexport default Lightbox;\n","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport Modal from 'react-modal';\n\nimport ITEM from '../../constants/item';\nimport Lightbox from '../Lightbox/Lightbox';\nimport {\n  LIGHTBOX_MOBILE_PADDING,\n  LIGHTBOX_PADDING,\n} from '../../constants/lightboxConstants';\nimport LAYOUT_CONSTANTS from '../../constants/layoutConstants';\n\nModal.setAppElement('#app');\n\nfunction LightBoxProvider({ title, type, srcList, toggle }) {\n  const [photoIndex, setPhotoIndex] = useState(0);\n\n  const close = () => {\n    toggle(false);\n  };\n\n  if (type === ITEM.SCULPTURE.TYPE) {\n    return (\n      <>\n        <Lightbox\n          mainSrc={srcList[photoIndex]}\n          nextSrc={srcList[(photoIndex + 1) % srcList.length]}\n          prevSrc={srcList[(photoIndex + srcList.length - 1) % srcList.length]}\n          onCloseRequest={() => close()}\n          onMovePrevRequest={() =>\n            setPhotoIndex((photoIndex + srcList.length - 1) % srcList.length)\n          }\n          onMoveNextRequest={() =>\n            setPhotoIndex((photoIndex + 1) % srcList.length)\n          }\n          imageTitle={`Marion Casters | ${title}`}\n          mobileSizeBreakpoint={LAYOUT_CONSTANTS.BREAKPOINT.MD}\n          imagePadding={LIGHTBOX_PADDING}\n          imageMobilePadding={LIGHTBOX_MOBILE_PADDING}\n        />\n      </>\n    );\n  }\n\n  return (\n    <>\n      <Lightbox\n        mainSrc={srcList[0]}\n        onCloseRequest={() => close()}\n        imageTitle={`Marion Casters | ${title}`}\n        imagePadding={LIGHTBOX_PADDING}\n        imageMobilePadding={LIGHTBOX_MOBILE_PADDING}\n      />\n    </>\n  );\n}\n\nLightBoxProvider.propTypes = {\n  title: PropTypes.string.isRequired,\n  type: PropTypes.string.isRequired,\n  srcList: PropTypes.array.isRequired,\n  toggle: PropTypes.func.isRequired,\n};\n\nexport default LightBoxProvider;\n","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\n\nimport s from './Image.css';\nimport ITEM from '../../../constants/item';\nimport LAYOUT_CONSTANTS from '../../../constants/layoutConstants';\nimport LightBoxProvider from '../../LightBoxProvider';\nimport ItemService from '../../../app-services/ItemService';\nimport useViewport from '../../Hooks/useViewport';\n\nfunction Image({ title, type }) {\n  const { width } = useViewport();\n  const [isOpen, setIsOpen] = useState(false);\n\n  const isLessThanSM = width < LAYOUT_CONSTANTS.BREAKPOINT.SM;\n  const itemService = new ItemService(type);\n  const itemPath = itemService.getPath();\n  const alt = itemService.getAltImage();\n  const isSculpture = itemService.getIsSculpture();\n\n  let currentImagePath;\n  let largeImagePath;\n\n  const setPath = () => {\n    currentImagePath = isLessThanSM\n      ? `${itemPath}/${ITEM.SM_SIZE}`\n      : `${itemPath}/${ITEM.MD_SIZE}`;\n    largeImagePath = isLessThanSM\n      ? `${itemPath}/${ITEM.MD_SIZE}`\n      : `${itemPath}`;\n  };\n\n  const lightBoxHandler = open => {\n    setIsOpen(open);\n  };\n\n  const getSrcList = isCurrent => {\n    const list = [];\n    const path = isCurrent ? `${currentImagePath}` : `${largeImagePath}`;\n\n    if (!isSculpture) {\n      list.push(`${path}/${title}.jpg`);\n    } else {\n      for (let i = 1; i < 5; i++) {\n        list.push(`${path}/${title}_${i}.jpg`);\n      }\n    }\n    return list;\n  };\n\n  const openLightBox = () => {\n    setIsOpen(true);\n  };\n\n  setPath();\n\n  const currentSrcList = getSrcList(true);\n  const largeSrcList = getSrcList(false);\n  return (\n    <>\n      <figure>\n        {currentSrcList.map(src => (\n          <button\n            type=\"button\"\n            className={isSculpture ? s.sculptureButton : s.imageButton}\n            onClick={openLightBox}\n            key={src}\n          >\n            <img src={src} alt={alt} className={s.image} />\n          </button>\n        ))}\n      </figure>\n      {isOpen && typeof window !== 'undefined' && (\n        <LightBoxProvider\n          title={title}\n          type={type}\n          srcList={largeSrcList}\n          toggle={lightBoxHandler}\n        />\n      )}\n    </>\n  );\n}\n\nImage.propTypes = {\n  title: PropTypes.string.isRequired,\n  type: PropTypes.string.isRequired,\n};\n\nexport default Image;\n","import ITEM from '../constants/item';\n\nclass ItemService {\n  constructor(type) {\n    this.constDatas = {};\n    this.isSculpture = false;\n    this.init(type);\n  }\n\n  init(type) {\n    if (type === ITEM.PAINTING.TYPE) {\n      this.constDatas = ITEM.PAINTING;\n    } else if (type === ITEM.DRAWING.TYPE) {\n      this.constDatas = ITEM.DRAWING;\n    } else if (type === ITEM.SCULPTURE.TYPE) {\n      this.constDatas = ITEM.SCULPTURE;\n      this.isSculpture = true;\n    } else throw new Error(`Type ${type} inexistant`);\n  }\n\n  get(name) {\n    if (!this.has(name)) {\n      throw new Error(`Property ${name} not found`);\n    }\n    return this.model[name];\n  }\n\n  has(name) {\n    return name in this.model;\n  }\n\n  getPath = () => {\n    return this.constDatas.PATH;\n  };\n\n  getTitle = () => {\n    return this.constDatas.TITLE;\n  };\n\n  getAltImage = () => {\n    return this.constDatas.ALT_IMAGE;\n  };\n\n  getIsSculpture = () => {\n    return this.isSculpture;\n  };\n}\n\nexport default ItemService;\n"],"sourceRoot":""}